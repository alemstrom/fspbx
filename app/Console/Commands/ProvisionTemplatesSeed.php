<?php

namespace App\Console\Commands;

use Illuminate\Console\Command;
use Illuminate\Support\Facades\File;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Str;
use App\Models\ProvisioningTemplate;

class ProvisionTemplatesSeed extends Command
{
    protected $signature = 'prov:templates:seed 
        {--vendor= : Only seed for a specific vendor folder}
        {--dry-run : Show what would change, don\'t write}
        {--dedupe-only : Skip seeding and only run checksum-based dedupe}';

    protected $description = 'Seed locked DEFAULT provisioning templates from resources/provisioning/<vendor>/<TemplateName> and dedupe by checksum';

    public function handle(): int
    {
        $base = resource_path('provisioning');
        if (!File::exists($base)) {
            $this->error("Missing folder: $base");
            return 1;
        }

        $dry = (bool)$this->option('dry-run');

        if (!$this->option('dedupe-only')) {
            [$inserted, $skipped] = $this->runSeeder($base, $dry);
            $this->info("Seed complete. Inserted: {$inserted}, Skipped: {$skipped}.");
        }

        // Always finish with a checksum-based dedupe pass
        [$removed, $repointed] = $this->runDedupe($dry);
        $this->info("Dedupe complete. Removed duplicates: {$removed}, Re-pointed devices: {$repointed}.");

        return 0;
    }

    private function runSeeder(string $base, bool $dry): array
    {
        $vendorFilter = strtolower((string)$this->option('vendor'));
        $inserted = 0; $skipped = 0;

        foreach (File::directories($base) as $vendorDir) {
            $vendor = strtolower(basename($vendorDir));
            if ($vendorFilter && $vendorFilter !== $vendor) continue;

            foreach (File::directories($vendorDir) as $tplDir) {
                $templateName = basename($tplDir); // folder name is the template name

                // enforce exactly one .blade.php per template folder
                $files = collect(File::files($tplDir))
                    ->filter(fn($f) => Str::endsWith($f->getFilename(), '.blade.php'))
                    ->values();

                if ($files->count() === 0) { $this->warn("[$vendor/$templateName] no .blade.php found"); continue; }
                if ($files->count() > 1)   { $this->error("[$vendor/$templateName] multiple .blade.php files—keep exactly one"); continue; }

                $file = $files->first();
                $src  = File::get($file->getPathname());
                $meta = $this->parseFrontMatter($src);

                $version = $meta['version'] ?? null;
                if (!$version || !preg_match('/^\d+\.\d+\.\d+$/', $version)) {
                    $this->error("[$vendor/$templateName] invalid or missing SemVer in {$file->getFilename()}");
                    continue;
                }

                $checksum = hash('sha256', $src);

                // Does this default release already exist?
                $existing = ProvisioningTemplate::where('vendor', $vendor)
                    ->where('name', $templateName)
                    ->where('type', 'default')
                    ->where('version', $version)
                    ->first();

                if ($existing) {
                    if ($existing->checksum === $checksum) {
                        $this->line("[skip] {$vendor}/{$templateName} @ {$version}");
                        $skipped++;
                        continue;
                    }
                    // Identity clash with different content → insist on version bump
                    $this->error("[conflict] {$vendor}/{$templateName} @ {$version} exists with different content. Bump version.");
                    continue;
                }

                $this->line(($dry ? '[dry]' : '[seed]')." {$vendor}/{$templateName} @ {$version}");

                if (!$dry) {
                    ProvisioningTemplate::create([
                        // template_uuid generated by DB default
                        'domain_uuid'  => null, 
                        'vendor'        => $vendor,
                        'name'          => $templateName,
                        'type'          => 'default',   // locked
                        'version'       => $version,    // SemVer
                        'revision'      => 0,           // defaults don’t use revisions
                        'base_template' => null,
                        'base_version'  => null,
                        'content'       => $src,
                        'checksum'      => $checksum,
                        'updated_by'    => null,
                    ]);
                }

                $inserted++;
            }
        }

        return [$inserted, $skipped];
    }

    /**
     * Simple checksum-based dedupe:
     * - Find checksums with count > 1 among DEFAULT templates
     * - Keep the OLDEST by created_at
     * - Re-point devices to the kept template
     * - Delete newer duplicates
     *
     * NOTE: This intentionally scopes to type='default'.
     * If you want to dedupe customs too, remove that where clause.
     */
    private function runDedupe(bool $dry): array
    {
        $removed = 0; $repointed = 0;
    
        // Find duplicate checksums among DEFAULT templates
        $dupeChecksums = DB::table('provisioning_templates')
            ->select('checksum')
            ->where('type', '=', 'default')
            ->groupBy('checksum')
            ->havingRaw('COUNT(*) > 1')   // ← use aggregate directly, not alias
            ->pluck('checksum');
    
        foreach ($dupeChecksums as $checksum) {
            // Keep the oldest row; remove the more recent ones
            $rows = ProvisioningTemplate::where('type', 'default')
                ->where('checksum', $checksum)
                ->orderBy('created_at', 'asc')
                ->get();
    
            if ($rows->count() < 2) continue;
    
            $keep   = $rows->first();
            $delete = $rows->slice(1);
            $idsToDelete = $delete->pluck('template_uuid')->all();
    
            $this->line(sprintf(
                "[dedupe] checksum=%s keep=%s delete=%s",
                substr($checksum, 0, 12) . '…',
                $keep->template_uuid,
                implode(',', $idsToDelete)
            ));
    
            if (!$dry) {
                DB::transaction(function () use ($idsToDelete, $keep, &$repointed, &$removed) {
                    // Re-point devices that referenced a duplicate to the kept template
                    $repointed += DB::table('v_devices')
                        ->whereIn('device_template_uuid', $idsToDelete)
                        ->update(['device_template_uuid' => $keep->template_uuid]);
    
                    // Remove newer duplicates
                    ProvisioningTemplate::whereIn('template_uuid', $idsToDelete)->delete();
                    $removed += count($idsToDelete);
                });
            } else {
                $removed += count($idsToDelete);
            }
        }
    
        return [$removed, $repointed];
    }

    /**
     * Parse Blade front-matter at the very top:
     * {{-- 
     * version: 1.0.8
     * --}}
     */
    private function parseFrontMatter(string $src): ?array
    {
        // Look only at the start of the file for speed
        $head = substr($src, 0, 8192);
    
        // Accept optional UTF-8 BOM, then Blade comment front-matter
        if (preg_match('/\A(?:\xEF\xBB\xBF)?\s*\{\{\-\-\s*(.*?)\s*\-\-\}\}/s', $head, $m)
            // Optional: also accept HTML comment style
            || preg_match('/\A(?:\xEF\xBB\xBF)?\s*<!--\s*(.*?)\s*-->/s', $head, $m)) {
    
            $out = [];
            foreach (preg_split('/\r?\n/', trim($m[1])) as $line) {
                if (preg_match('/^\s*([A-Za-z0-9_\-]+)\s*:\s*(.+?)\s*$/', $line, $kv)) {
                    $out[strtolower($kv[1])] = trim($kv[2]);
                }
            }
            return $out;
        }
    
        return null;
    }
    
}
